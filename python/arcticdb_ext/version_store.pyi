from typing import Any, ClassVar, Dict, List, Optional, Tuple, Union

from typing import overload
import arcticdb_ext.exceptions
import arcticdb_ext.storage
import arcticdb_ext.stream
import arcticdb_ext.tools
import numpy

class AggregationClause:
    def __init__(self, arg0: str, arg1: Dict[str,str]) -> None: ...

class AtomKey:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Union[int,str], arg1: int, arg2: int, arg3: int, arg4: Union[int,str], arg5: Union[int,str], arg6: arcticdb_ext.storage.KeyType) -> None: ...
    def change_id(self, arg0: Union[int,str]) -> Union[int,str]: ...
    def __eq__(self, arg0: AtomKey) -> bool: ...
    def __ne__(self, arg0: AtomKey) -> bool: ...
    @property
    def content_hash(self) -> int: ...
    @property
    def creation_ts(self) -> int: ...
    @property
    def end_index(self) -> Union[int,str]: ...
    @property
    def id(self) -> Union[int,str]: ...
    @property
    def start_index(self) -> Union[int,str]: ...
    @property
    def type(self) -> arcticdb_ext.storage.KeyType: ...
    @property
    def version_id(self) -> int: ...

class ColRange:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def diff(self) -> int: ...
    @property
    def end(self) -> int: ...
    @property
    def start(self) -> int: ...

class ColumnName:
    def __init__(self, arg0: str) -> None: ...

class ColumnStats:
    def __init__(self, arg0: Dict[str,Set[str]]) -> None: ...
    def to_map(self) -> Dict[str,Set[str]]: ...

class DataError:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def error_category(self) -> Optional[arcticdb_ext.exceptions.ErrorCategory]: ...
    @property
    def error_code(self) -> Optional[arcticdb_ext.exceptions.ErrorCode]: ...
    @property
    def exception_string(self) -> str: ...
    @property
    def symbol(self) -> str: ...
    @property
    def version_request_data(self) -> Optional[Union[None,int,str]]: ...
    @property
    def version_request_type(self) -> Optional[VersionRequestType]: ...

class DateRangeClause:
    def __init__(self, arg0: int, arg1: int) -> None: ...
    @property
    def end(self) -> int: ...
    @property
    def start(self) -> int: ...

class DescriptorItem:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def creation_ts(self) -> int: ...
    @property
    def end_index(self) -> Optional[Union[int,str]]: ...
    @property
    def start_index(self) -> Optional[Union[int,str]]: ...
    @property
    def symbol(self) -> str: ...
    @property
    def timeseries_descriptor(self) -> object: ...
    @property
    def version(self) -> int: ...

class ExpressionContext:
    root_node_name: ExpressionName
    def __init__(self) -> None: ...
    def add_expression_node(self, arg0: str, arg1: ExpressionNode) -> None: ...
    def add_value(self, arg0: str, arg1: ValueType) -> None: ...
    def add_value_set(self, arg0: str, arg1: ValueSet) -> None: ...

class ExpressionName:
    def __init__(self, arg0: str) -> None: ...

class ExpressionNode:
    @overload
    def __init__(self, arg0: Union[None,ColumnName,ValueName,ValueSetName,ExpressionName], arg1: Union[None,ColumnName,ValueName,ValueSetName,ExpressionName], arg2: OperationType) -> None: ...
    @overload
    def __init__(self, arg0: Union[None,ColumnName,ValueName,ValueSetName,ExpressionName], arg1: OperationType) -> None: ...

class FilterClause:
    def __init__(self, arg0: Set[str], arg1, arg2) -> None: ...
    def set_pipeline_optimisation(self, arg0) -> None: ...

class FrameDataWrapper:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def data(self) -> List[numpy.ndarray]: ...

class FrameSlice:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def col_range(self) -> Any: ...
    @property
    def row_range(self) -> Any: ...

class GroupByClause:
    def __init__(self, arg0: str) -> None: ...
    @property
    def grouping_column(self) -> str: ...

class IndexRange:
    def __init__(self, arg0: int, arg1: int) -> None: ...
    @property
    def end_ts(self) -> int: ...
    @property
    def start_ts(self) -> int: ...

class ManualClockVersionStore(PythonVersionStore):
    time: ClassVar[int] = ...
    def __init__(self, arg0: arcticdb_ext.storage.Library) -> None: ...

class NoSuchVersionException(arcticdb_ext.storage.NoDataFoundException): ...

class OperationType:
    __members__: ClassVar[dict] = ...  # read-only
    ABS: ClassVar[OperationType] = ...
    ADD: ClassVar[OperationType] = ...
    AND: ClassVar[OperationType] = ...
    DIV: ClassVar[OperationType] = ...
    EQ: ClassVar[OperationType] = ...
    GE: ClassVar[OperationType] = ...
    GT: ClassVar[OperationType] = ...
    IDENTITY: ClassVar[OperationType] = ...
    ISIN: ClassVar[OperationType] = ...
    ISNOTIN: ClassVar[OperationType] = ...
    LE: ClassVar[OperationType] = ...
    LT: ClassVar[OperationType] = ...
    MUL: ClassVar[OperationType] = ...
    NE: ClassVar[OperationType] = ...
    NEG: ClassVar[OperationType] = ...
    NOT: ClassVar[OperationType] = ...
    OR: ClassVar[OperationType] = ...
    SUB: ClassVar[OperationType] = ...
    XOR: ClassVar[OperationType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PipelineOptimisation:
    __members__: ClassVar[dict] = ...  # read-only
    MEMORY: ClassVar[PipelineOptimisation] = ...
    SPEED: ClassVar[PipelineOptimisation] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ProjectClause:
    def __init__(self, arg0: Set[str], arg1: str, arg2) -> None: ...

class PythonOutputFrame:
    @overload
    def __init__(self, arg0: arcticdb_ext.stream.SegmentInMemory, arg1) -> None: ...
    @overload
    def __init__(self, arg0: arcticdb_ext.stream.SegmentInMemory) -> None: ...
    @property
    def index_columns(self) -> List[str]: ...
    @property
    def names(self) -> List[str]: ...
    @property
    def offset(self) -> int: ...
    @property
    def value(self) -> FrameDataWrapper: ...

class PythonVersionStore:
    def __init__(self, library: arcticdb_ext.storage.Library, license_key: Optional[str] = ...) -> None: ...
    def _clear_symbol_list_keys(self) -> None: ...
    def _compact_version_map(self, arg0: Union[int,str]) -> None: ...
    def _get_all_tombstoned_versions(self, arg0: Union[int,str]) -> Dict[int,bool]: ...
    def _get_version_history(self, arg0: Union[int,str]) -> List[AtomKey]: ...
    def _set_validate_version_map(self) -> None: ...
    def add_to_snapshot(self, arg0: Union[int,str], arg1: List[Union[int,str]], arg2: List[PythonVersionStoreVersionQuery]) -> None: ...
    def append(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: object, arg4: bool, arg5: bool, arg6: bool) -> VersionedItem: ...
    def append_incomplete(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: object) -> None: ...
    def batch_append(self, arg0: List[Union[int,str]], arg1: List[tuple], arg2: List[object], arg3: List[object], arg4: bool, arg5: bool, arg6: bool, arg7: bool) -> List[Union[VersionedItem,DataError]]: ...
    def batch_read(self, arg0: List[Union[int,str]], arg1: List[PythonVersionStoreVersionQuery], arg2: List[PythonVersionStoreReadQuery], arg3: PythonVersionStoreReadOptions) -> list: ...
    def batch_read_descriptor(self, arg0: List[Union[int,str]], arg1: List[PythonVersionStoreVersionQuery], arg2: PythonVersionStoreReadOptions) -> List[Union[DescriptorItem,DataError]]: ...
    def batch_read_keys(self, arg0: List[AtomKey]) -> list: ...
    def batch_read_metadata(self, arg0: List[Union[int,str]], arg1: List[PythonVersionStoreVersionQuery], arg2: PythonVersionStoreReadOptions) -> List[Union[Tuple[VersionedItem,object],DataError]]: ...
    def batch_restore_version(self, arg0: List[Union[int,str]], arg1: List[PythonVersionStoreVersionQuery]) -> List[object]: ...
    def batch_write(self, arg0: List[Union[int,str]], arg1: List[tuple], arg2: List[object], arg3: List[object], arg4: bool, arg5: bool, arg6: bool) -> List[Union[VersionedItem,DataError]]: ...
    def batch_write_metadata(self, arg0: List[Union[int,str]], arg1: List[object], arg2: bool, arg3: bool) -> List[Union[VersionedItem,DataError]]: ...
    def check_ref_key(self, arg0: Union[int,str]) -> bool: ...
    def clear(self) -> None: ...
    def compact_incomplete(self, stream_id: Union[int,str], append: bool, convert_int_to_float: bool, via_iteration: bool = ..., sparsify: bool = ..., user_meta: Optional[object] = ..., prune_previous_versions: bool = ...) -> VersionedItem: ...
    def compact_library(self, arg0: int) -> None: ...
    def create_column_stats_version(self, arg0: Union[int,str], arg1: ColumnStats, arg2: PythonVersionStoreVersionQuery) -> None: ...
    def defragment_symbol_data(self, arg0: Union[int,str], arg1: Optional[int]) -> VersionedItem: ...
    def delete(self, arg0: Union[int,str]) -> None: ...
    def delete_range(self, arg0: Union[int,str], arg1: PythonVersionStoreUpdateQuery, arg2: bool) -> VersionedItem: ...
    def delete_snapshot(self, arg0: Union[int,str]) -> None: ...
    def delete_storage(self) -> None: ...
    def delete_version(self, arg0: Union[int,str], arg1: int) -> None: ...
    def drop_column_stats_version(self, arg0: Union[int,str], arg1: Optional[ColumnStats], arg2: PythonVersionStoreVersionQuery) -> None: ...
    def dump_versions(self, arg0: Union[int,str]) -> str: ...
    def empty(self) -> bool: ...
    def find_version(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery, arg2: PythonVersionStoreReadOptions) -> Optional[VersionedItem]: ...
    def fix_ref_key(self, arg0: Union[int,str]) -> None: ...
    def fix_symbol_trees(self, arg0: List[Union[int,str]]) -> None: ...
    def flush_version_map(self) -> None: ...
    def force_delete_symbol(self, arg0: Union[int,str]) -> None: ...
    def force_release_lock(self, arg0: Union[int,str]) -> None: ...
    def get_active_incomplete_refs(self) -> Set[Union[int,str]]: ...
    def get_column_stats_info_version(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery) -> ColumnStats: ...
    def get_incomplete_refs(self) -> Set[Union[int,str]]: ...
    def get_incomplete_symbols(self) -> Set[Union[int,str]]: ...
    def get_storage_lock(self, arg0: Union[int,str]) -> arcticdb_ext.tools.StorageLock: ...
    def get_store_current_timestamp_for_tests(self) -> int: ...
    def get_update_time(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery) -> int: ...
    def get_update_times(self, arg0: List[Union[int,str]], arg1: List[PythonVersionStoreVersionQuery]) -> List[int]: ...
    def is_symbol_fragmented(self, arg0: Union[int,str], arg1: Optional[int]) -> bool: ...
    def latest_timestamp(self, arg0: str) -> int: ...
    def list_incompletes(self, *args, **kwargs) -> Any: ...
    def list_snapshots(self, arg0: Optional[bool]) -> List[Tuple[Union[int,str],object]]: ...
    def list_streams(self, arg0: Optional[Union[int,str]], arg1: Optional[str], arg2: Optional[str], arg3: Optional[bool], arg4: Optional[bool]) -> Set[Union[int,str]]: ...
    def list_versions(self, arg0: Optional[Union[int,str]], arg1: Optional[Union[int,str]], arg2: Optional[bool], arg3: Optional[bool], arg4: Optional[bool]) -> List[Tuple[Union[int,str],int,int,List[Union[int,str]],bool]]: ...
    def prune_previous_versions(self, arg0: Union[int,str]) -> None: ...
    def push_incompletes_to_symbol_list(self, arg0: Set[Union[int,str]]) -> None: ...
    def read_column_stats_version(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery) -> tuple: ...
    def read_dataframe_version(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery, arg2: PythonVersionStoreReadQuery, arg3: PythonVersionStoreReadOptions) -> tuple: ...
    def read_descriptor(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery, arg2: PythonVersionStoreReadOptions) -> DescriptorItem: ...
    def read_index(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery) -> tuple: ...
    def read_latest_dataframe_merged(self, arg0: Union[int,str], arg1: List[Union[int,str]], arg2: PythonVersionStoreReadQuery, arg3: PythonVersionStoreReadOptions) -> tuple: ...
    def read_metadata(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery, arg2: PythonVersionStoreReadOptions) -> Tuple[VersionedItem,object]: ...
    def reload_symbol_list(self) -> None: ...
    def remove_and_rewrite_version_keys(self, arg0: Union[int,str]) -> None: ...
    def remove_from_snapshot(self, arg0: Union[int,str], arg1: List[Union[int,str]], arg2: List[int]) -> None: ...
    def remove_incomplete(self, arg0: Union[int,str]) -> None: ...
    def restore_version(self, arg0: Union[int,str], arg1: PythonVersionStoreVersionQuery) -> tuple: ...
    def scan_object_sizes(self) -> Dict[arcticdb_ext.storage.KeyType,Tuple[int,int]]: ...
    def snapshot(self, arg0: Union[int,str], arg1: object, arg2: List[Union[int,str]], arg3: Dict[Union[int,str],int]) -> None: ...
    def sort_index(self, arg0: Union[int,str], arg1: bool) -> VersionedItem: ...
    @overload
    def sort_merge(self, stream_id: Union[int,str], user_meta: object = ..., append: bool = ..., convert_int_to_float: bool = ..., via_iteration: bool = ..., sparsify: bool = ...) -> VersionedItem: ...
    @overload
    def sort_merge(self, arg0: Union[int,str], arg1: object, arg2: bool, arg3: bool, arg4: bool, arg5: bool) -> VersionedItem: ...
    def update(self, arg0: Union[int,str], arg1: PythonVersionStoreUpdateQuery, arg2: tuple, arg3: object, arg4: object, arg5: bool, arg6: bool, arg7: bool) -> VersionedItem: ...
    def write_dataframe_specific_version(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: object, arg4: int) -> VersionedItem: ...
    def write_metadata(self, arg0: Union[int,str], arg1: object, arg2: bool) -> VersionedItem: ...
    def write_parallel(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: object) -> None: ...
    @overload
    def write_partitioned_dataframe(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: List[str]) -> VersionedItem: ...
    @overload
    def write_partitioned_dataframe(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: List[str]) -> VersionedItem: ...
    def write_versioned_composite_data(self, arg0: Union[int,str], arg1: object, arg2: List[Union[int,str]], arg3: List[tuple], arg4: List[object], arg5: object, arg6: bool) -> VersionedItem: ...
    def write_versioned_dataframe(self, arg0: Union[int,str], arg1: tuple, arg2: object, arg3: object, arg4: bool, arg5: bool, arg6: bool) -> VersionedItem: ...

class PythonVersionStoreReadOptions:
    def __init__(self) -> None: ...
    def set_allow_sparse(self, arg0: Optional[bool]) -> None: ...
    def set_batch_throw_on_error(self, arg0: bool) -> None: ...
    def set_dynamic_schema(self, arg0: Optional[bool]) -> None: ...
    def set_force_strings_to_object(self, arg0: Optional[bool]) -> None: ...
    def set_incompletes(self, arg0: Optional[bool]) -> None: ...
    def set_optimise_string_memory(self, arg0: Optional[bool]) -> None: ...
    def set_set_tz(self, arg0: Optional[bool]) -> None: ...
    @property
    def incompletes(self) -> bool: ...

class PythonVersionStoreReadQuery:
    columns: List[str]
    row_filter: Union[None,IndexRange,RowRange]
    row_range: Optional[SignedRowRange]
    def __init__(self) -> None: ...
    def add_clauses(self, arg0: List[Union[FilterClause,ProjectClause,GroupByClause,AggregationClause,RowRangeClause,DateRangeClause]]) -> None: ...

class PythonVersionStoreUpdateQuery:
    row_filter: Union[None,IndexRange,RowRange]
    def __init__(self) -> None: ...

class PythonVersionStoreVersionQuery:
    def __init__(self) -> None: ...
    def set_iterate_on_failure(self, arg0: Optional[bool]) -> None: ...
    def set_skip_compat(self, arg0: Optional[bool]) -> None: ...
    def set_snap_name(self, arg0: str) -> None: ...
    def set_timestamp(self, arg0: int) -> None: ...
    def set_version(self, arg0: int) -> None: ...

class RefKey:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Union[int,str], arg1: arcticdb_ext.storage.KeyType) -> None: ...
    def __eq__(self, arg0: RefKey) -> bool: ...
    def __ne__(self, arg0: RefKey) -> bool: ...
    @property
    def id(self) -> Union[int,str]: ...
    @property
    def type(self) -> arcticdb_ext.storage.KeyType: ...

class RowRange:
    def __init__(self, arg0: int, arg1: int) -> None: ...
    @property
    def diff(self) -> int: ...
    @property
    def end(self) -> int: ...
    @property
    def start(self) -> int: ...

class RowRangeClause:
    def __init__(self, arg0: RowRangeType, arg1: int) -> None: ...

class RowRangeType:
    __members__: ClassVar[dict] = ...  # read-only
    HEAD: ClassVar[RowRangeType] = ...
    TAIL: ClassVar[RowRangeType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SignedRowRange:
    def __init__(self, arg0: int, arg1: int) -> None: ...

class SortedValue:
    __members__: ClassVar[dict] = ...  # read-only
    ASCENDING: ClassVar[SortedValue] = ...
    DESCENDING: ClassVar[SortedValue] = ...
    UNKNOWN: ClassVar[SortedValue] = ...
    UNSORTED: ClassVar[SortedValue] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StreamDescriptorMismatch(arcticdb_ext.exceptions.ArcticException): ...

class ValueName:
    def __init__(self, arg0: str) -> None: ...

class ValueSet:
    @overload
    def __init__(self, arg0: List[str]) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray) -> None: ...

class ValueSetName:
    def __init__(self, arg0: str) -> None: ...

class ValueType:
    def __init__(self) -> None: ...

class VersionRequestType:
    __members__: ClassVar[dict] = ...  # read-only
    LATEST: ClassVar[VersionRequestType] = ...
    SNAPSHOT: ClassVar[VersionRequestType] = ...
    SPECIFIC: ClassVar[VersionRequestType] = ...
    TIMESTAMP: ClassVar[VersionRequestType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VersionedEngine:
    def __init__(self, arg0: arcticdb_ext.storage.Library) -> None: ...
    def read_versioned_dataframe(self, *args, **kwargs) -> Any: ...

class VersionedItem:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self) -> str: ...
    @property
    def version(self) -> int: ...

@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: int) -> ValueType: ...
@overload
def Value(arg0: float) -> ValueType: ...
@overload
def Value(arg0: float) -> ValueType: ...
@overload
def Value(arg0: str) -> ValueType: ...
def ValueBool(arg0: bool) -> ValueType: ...
def ValueFloat32(arg0: float) -> ValueType: ...
def ValueFloat64(arg0: float) -> ValueType: ...
def ValueInt16(arg0: int) -> ValueType: ...
def ValueInt32(arg0: int) -> ValueType: ...
def ValueInt64(arg0: int) -> ValueType: ...
def ValueInt8(arg0: int) -> ValueType: ...
def ValueUint16(arg0: int) -> ValueType: ...
def ValueUint32(arg0: int) -> ValueType: ...
def ValueUint64(arg0: int) -> ValueType: ...
def ValueUint8(arg0: int) -> ValueType: ...
